# 增量更新策略

> 本文档说明 AI Context 框架如何实现增量更新，确保自动生成内容与手动编辑内容的协调共存。

---

## 区块标记系统

### 标记语法

框架使用 HTML 注释作为区块标记，区分自动维护和手动编辑的内容：

```markdown
<!-- AUTO_SYNC: section-name | updated=2026-02-03 -->
[自动生成的内容 - 会被系统更新]
<!-- END_AUTO_SYNC -->

<!-- MANUAL: custom-notes -->
[用户手动添加的内容 - 永远不被覆盖]
<!-- END_MANUAL -->
```

### AUTO_SYNC 区块

**用途**: 标记由系统自动维护的内容

**属性**:
- `section-name`: 区块唯一标识符
- `updated`: 最后更新时间戳

**行为**:
- doc-maintainer 可以自动更新这些区块
- 更新时会自动刷新时间戳
- 内容完全由系统管理

**示例**:
```markdown
<!-- AUTO_SYNC: file-structure | updated=2026-02-03 -->

```
/src/payment/
├── _AI_CONTEXT.md     - 本文档
├── index.ts           - 模块入口
├── processor.ts       - 支付处理核心
└── gateway/
    ├── stripe.ts      - Stripe 适配器
    └── paypal.ts      - PayPal 适配器
```

<!-- END_AUTO_SYNC -->
```

### MANUAL 区块

**用途**: 标记用户手动编辑的内容，系统永远不会修改

**属性**:
- `custom-notes`: 区块标识（可选描述性名称）

**行为**:
- doc-maintainer 永远不修改这些区块
- 用户完全控制内容
- 适合存放经验总结、特殊注意事项

**示例**:
```markdown
<!-- MANUAL: special-notes -->

### 团队约定
- 所有支付金额使用分为单位（避免浮点数精度问题）
- 退款操作必须记录操作人和原因
- 测试环境使用 Stripe 测试密钥

### 历史坑点
- 2025-06 曾因并发问题导致重复扣款，已通过幂等性检查解决

<!-- END_MANUAL -->
```

---

## 更新策略

### 策略流程

```
┌─────────────────────────────────────────────────────────┐
│                    增量更新流程                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 读取现有文档                                         │
│     ├── 解析所有 AUTO_SYNC 区块                         │
│     ├── 解析所有 MANUAL 区块                            │
│     └── 记录区块位置和内容                               │
│                        ↓                                │
│  2. 识别更新目标                                         │
│     ├── AI 分析代码变更                                 │
│     ├── 判断影响哪些 AUTO_SYNC 区块                     │
│     └── 生成更新内容                                    │
│                        ↓                                │
│  3. 执行更新                                            │
│     ├── 替换目标 AUTO_SYNC 区块内容                     │
│     ├── 更新时间戳                                      │
│     └── 完整保留 MANUAL 区块                            │
│                        ↓                                │
│  4. 写入文件                                            │
│     └── 保持文档整体结构不变                             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 更新原则

#### 1. 最小化更新

```markdown
✅ 正确做法：
- 只更新受影响的 AUTO_SYNC 区块
- 保持其他内容完全不变
- 不重新格式化文档

❌ 错误做法：
- 重新生成整个文档
- 调整未变更部分的格式
- 移动区块位置
```

#### 2. 保守更新

```markdown
更新触发条件（必须满足）：
- 代码变更确实影响了文档描述的内容
- AI 有足够信心理解变更的含义
- 新内容与现有内容有实质性差异

不更新的情况：
- 纯重构（行为不变）
- 代码注释修改
- 内部实现细节变化
- 不确定变更含义时
```

#### 3. 尊重手动内容

```markdown
MANUAL 区块保护规则：
- 永远不修改 MANUAL 区块内的任何字符
- 永远不移动 MANUAL 区块的位置
- 永远不删除 MANUAL 区块
- 即使周围 AUTO_SYNC 内容变化，MANUAL 保持不动
```

---

## 区块类型对照表

| 文档部分 | 推荐类型 | 说明 |
|---------|---------|------|
| 职责范围 | AUTO_SYNC | 可从代码结构推断 |
| 文件结构 | AUTO_SYNC | 直接反映目录内容 |
| 关键接口 | AUTO_SYNC | 可从代码提取 |
| 依赖关系 | AUTO_SYNC | 可从 import 分析 |
| 注意事项 | MANUAL | 需要人工经验 |
| 扩展指南 | MANUAL | 需要人工总结 |
| 历史坑点 | MANUAL | 团队经验积累 |

---

## 冲突处理

### 场景 1: AUTO_SYNC 内容被手动修改

```markdown
问题：用户直接编辑了 AUTO_SYNC 区块内容

处理方式：
1. 系统更新时会覆盖手动修改
2. 建议：如需保留自定义内容，移至 MANUAL 区块

预防措施：
- 文档中说明 AUTO_SYNC 区块会被自动更新
- 提供明确的 MANUAL 区块供用户添加自定义内容
```

### 场景 2: 区块标记损坏

```markdown
问题：HTML 注释标记被意外修改或删除

处理方式：
1. 系统检测到标记不完整时跳过该区块
2. 输出警告日志
3. 不尝试自动修复

修复方法：
- 用户手动修复标记格式
- 或删除损坏的标记，让系统重新生成
```

### 场景 3: 新增区块

```markdown
问题：代码变更引入了新的需要文档化的内容

处理方式：
1. 在合适位置插入新的 AUTO_SYNC 区块
2. 不影响现有区块的位置
3. 遵循文档模板的章节顺序
```

---

## 最佳实践

### 文档初始化时

```markdown
1. 使用标准模板创建文档
2. AUTO_SYNC 区块用于可自动维护的内容
3. 预留 MANUAL 区块供后续补充
4. 初始 MANUAL 区块可以是空的占位符
```

### 日常维护时

```markdown
1. 让系统自动维护 AUTO_SYNC 区块
2. 团队成员在 MANUAL 区块记录经验
3. 定期检查 AUTO_SYNC 内容是否准确
4. 发现不准确时，优先修复代码而非文档
```

### 大型重构后

```markdown
1. 自动更新可能不够完整
2. 建议人工检查所有 AUTO_SYNC 区块
3. 更新 MANUAL 区块中过时的内容
4. 考虑是否需要新增/删除区块
```

---

## 技术实现要点

### 区块解析正则

```python
import re

# 匹配 AUTO_SYNC 区块
AUTO_SYNC_PATTERN = re.compile(
    r'<!-- AUTO_SYNC: (\S+)(?: \| updated=(\S+))? -->\n'
    r'(.*?)'
    r'<!-- END_AUTO_SYNC -->',
    re.DOTALL
)

# 匹配 MANUAL 区块
MANUAL_PATTERN = re.compile(
    r'<!-- MANUAL: (\S+) -->\n'
    r'(.*?)'
    r'<!-- END_MANUAL -->',
    re.DOTALL
)
```

### 区块更新函数

```python
def update_auto_sync_block(content: str, section_name: str, new_content: str) -> str:
    """更新指定的 AUTO_SYNC 区块"""
    from datetime import date
    
    today = date.today().isoformat()
    
    def replacer(match):
        if match.group(1) == section_name:
            return f'<!-- AUTO_SYNC: {section_name} | updated={today} -->\n{new_content}\n<!-- END_AUTO_SYNC -->'
        return match.group(0)
    
    return AUTO_SYNC_PATTERN.sub(replacer, content)
```

---

## 相关文档

- [001-Git-Hook机制.md](./001-Git-Hook机制.md) - 触发更新的机制
- [002-doc-maintainer设计.md](./002-doc-maintainer设计.md) - 分析和生成更新内容
- [004-验证与测试方案.md](./004-验证与测试方案.md) - 验证更新结果
